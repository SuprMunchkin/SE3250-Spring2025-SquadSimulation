<!DOCTYPE html>
<html>
<head>
    <title>Simulation Control</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
        }
        #simulation-form {
            display: inline-block;
            text-align: center;
            margin-bottom: 24px;
        }
        .form-group {
            margin-bottom: 18px;
            text-align: center;
        }
        .form-group label,
        .form-group input,
        .form-group select {
            display: block;
            margin: 0 auto;
        }
        #simulation-container {
            margin: 20px auto;
            position: relative;
            width: 1000px;
            height: 1000px;
            border: 1px solid black;
            background-color: #f0f0f0;
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
        }
    </style>
</head>
<body>
    <h1>Simulation Control</h1>
    <form id="simulation-form" onsubmit="event.preventDefault(); startSimulation();">
        <div class="form-group">
            <label for="blue_stock">Blue Stock:</label>
            <input type="number" id="blue_stock" name="blue_stock" value="10" min="1" max="20">
            <br>
            <label for="hostile_stock">Hostile Stock:</label>
            <input type="number" id="hostile_stock" name="hostile_stock" value="10" min="1" max="40">
            <br>
            <label for="direction_deviation">Direction Deviation:</label>
            <input type="number" id="direction_deviation" name="direction_deviation" value="10" min="0" max="45" step="5">
        </div>
        <div class="form-group">
            <label for="armor_type">Armor Type:</label>
            <select id="armor_type" name="armor_type">
                <option value="Basilone Ballistic Insert">Basilone Ballistic Insert</option>
                <option value="Chesty Ballistic Insert">Chesty Ballistic Insert</option>
                <option value="Hathcock Ballistic Insert">Hathcock Ballistic Insert</option>
            </select>
            <br>
            <label for="environment">Environment:</label>
            <select id="environment" name="environment">
                <option value="Krulakâ€™s Three Block War">Krulakâ€™s Three Block War</option>
                <option value="Pershingâ€™s Ghost">Pershingâ€™s Ghost</option>
                <option value="Nightmare from Mattis Street">Nightmare from Mattis Street</option>
            </select>
        </div>
        <div class="form-group">
            <button type="submit">Run Simulation</button>
        </div>
    </form>
    <div id="simulation-container">
        <canvas id="simulation-canvas" width="1000" height="1000"></canvas>
    </div>
    <pre id="results"></pre>
    <script>
        const canvas = document.getElementById('simulation-canvas');
        const ctx = canvas.getContext('2d');
        const resultsElement = document.getElementById('results');
        let path = [];
        let combats = [];
        let index = 0;
        let animationFrameId = null;
        let frameDelay = 5; // Number of frames to wait before moving to the next point
        let frameCounter = 0;

        function drawUnit(x, y) {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas

            // Draw combat locations that have already occurred
            combats.slice(0, index).forEach(([cx, cy]) => {
                ctx.fillStyle = 'red'; // Red for combat locations
                ctx.beginPath();
                ctx.arc(cx * canvas.width, cy * canvas.height, 5, 0, Math.PI * 2); // Small red circle
                ctx.fill();
            });

            // Draw the good unit
            ctx.fillStyle = 'blue'; // Blue for the good unit
            ctx.beginPath();
            ctx.arc(x * canvas.width, y * canvas.height, 10, 0, Math.PI * 2); // Larger blue circle
            ctx.fill();
        }

        function moveUnit() {
            if (index >= path.length) {
                cancelAnimationFrame(animationFrameId); // Stop the animation
                return;
            }

            // Increment the frame counter and only move the unit after the delay
            if (frameCounter === 0) {
                const [x, y] = path[index];
                drawUnit(x, y);

                // Check if a combat occurred at this location
                if (combats[index]) {
                    combats.push(combats[index]); // Add combat location dynamically
                }

                index++;
            }

            frameCounter = (frameCounter + 1) % frameDelay; // Reset the counter after the delay
            animationFrameId = requestAnimationFrame(moveUnit); // Schedule the next frame
        }

        function startSimulation() {
            const form = document.getElementById('simulation-form');
            const formData = new FormData(form);
            const params = new URLSearchParams(formData).toString();
            fetch(`/run_simulation?${params}`)
                .then(response => response.json())
                .then(data => {
                    // Display the results
                    drawPaths(data.positions, data.hostile_positions);
                    document.getElementById('results').textContent = formatResults(data);
                });
        }

        function drawPaths(bluePath, hostilePath) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw blue path
            if (bluePath && bluePath.length > 0) {
                ctx.strokeStyle = 'blue';
                ctx.beginPath();
                bluePath.forEach(([x, y], i) => {
                    let sx = x / 5000 * canvas.width;
                    let sy = (5000-y) / 5000 * canvas.height;
                    if (i === 0) ctx.moveTo(sx, sy);
                    else ctx.lineTo(sx, sy);
                });
                ctx.stroke();

                // Draw blue unit as a blue circle at its last position
                let [bx, by] = bluePath[bluePath.length - 1];
                let bsx = bx / 5000 * canvas.width;
                let bsy = (5000-by) / 5000 * canvas.height;
                ctx.fillStyle = 'blue';
                ctx.beginPath();
                ctx.arc(bsx, bsy, 5, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw hostile path
            if (hostilePath && hostilePath.length > 0) {
                ctx.strokeStyle = 'red';
                ctx.beginPath();
                hostilePath.forEach(([x, y], i) => {
                    let sx = x / 5000 * canvas.width;
                    let sy = (5000-y) / 5000 * canvas.height;
                    if (i === 0) ctx.moveTo(sx, sy);
                    else ctx.lineTo(sx, sy);
                });
                ctx.stroke();

                // Draw hostile unit as a red circle at its last position
                let [hx, hy] = hostilePath[hostilePath.length - 1];
                let hsx = hx / 5000 * canvas.width;
                let hsy = (5000-hy) / 5000 * canvas.height;
                ctx.fillStyle = 'red';
                ctx.beginPath();
                ctx.arc(hsx, hsy, 5, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function stopSimulation() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId); // Cancel the animation
                animationFrameId = null;
            }
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas
        }

        function formatResults(data) {
            let output = `ðŸ‘¥ Blue Remaining: ${data.blue.stock}\n`;
            output += `ðŸ”´ Hostile Remaining: ${data.hostile.stock}\n`;
            return output;
        }
    </script>
</body>
</html>